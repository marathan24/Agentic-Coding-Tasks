{
    "results": {
        "tool": {
            "name": "pytest",
            "version": "8.4.1"
        },
        "summary": {
            "tests": 18,
            "passed": 14,
            "failed": 4,
            "skipped": 0,
            "pending": 0,
            "other": 0,
            "start": 1764017937.6692226,
            "stop": 1764017937.847547
        },
        "tests": [
            {
                "name": "test_queries.py::test_service_is_running",
                "status": "passed",
                "duration": 0.005166250000002037,
                "start": 1764017937.740666,
                "stop": 1764017937.7460139,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_stats_endpoint",
                "status": "passed",
                "duration": 0.0036732080000092537,
                "start": 1764017937.7461295,
                "stop": 1764017937.749907,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_electronics_phones",
                "status": "passed",
                "duration": 0.0037124170000311096,
                "start": 1764017937.7500086,
                "stop": 1764017937.7538316,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_furniture_chairs",
                "status": "passed",
                "duration": 0.0036097490000202015,
                "start": 1764017937.7539394,
                "stop": 1764017937.7576425,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_clothing_shoes",
                "status": "passed",
                "duration": 0.0035753750000253604,
                "start": 1764017937.7577357,
                "stop": 1764017937.7613978,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_food_fruits",
                "status": "passed",
                "duration": 0.0036367079999877205,
                "start": 1764017937.7614822,
                "stop": 1764017937.765203,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_books_fiction",
                "status": "passed",
                "duration": 0.003609457000038674,
                "start": 1764017937.7652998,
                "stop": 1764017937.769006,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_nonexistent_combination",
                "status": "passed",
                "duration": 0.0036452489999305726,
                "start": 1764017937.7690988,
                "stop": 1764017937.7728286,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_missing_type1",
                "status": "passed",
                "duration": 0.005827499000019998,
                "start": 1764017937.7729177,
                "stop": 1764017937.7788377,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_missing_type2",
                "status": "passed",
                "duration": 0.0034998340000242933,
                "start": 1764017937.7789414,
                "stop": 1764017937.7825234,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_query_performance",
                "status": "passed",
                "duration": 0.0033827920000248923,
                "start": 1764017937.7826033,
                "stop": 1764017937.7860668,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_multiple_records_same_combination",
                "status": "passed",
                "duration": 0.003406166000047506,
                "start": 1764017937.7861555,
                "stop": 1764017937.7896404,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_all_records_queryable",
                "status": "passed",
                "duration": 0.019337624999991476,
                "start": 1764017937.7897198,
                "stop": 1764017937.80914,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_concurrent_queries",
                "status": "passed",
                "duration": 0.00603875000001608,
                "start": 1764017937.8092275,
                "stop": 1764017937.8153608,
                "retries": 0,
                "file_path": "test_queries.py"
            },
            {
                "name": "test_queries.py::test_single_query_loads_exactly_one_type1_and_one_type2",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0038450420000231134,
                "start": 1764017937.815461,
                "stop": 1764017937.828486,
                "retries": 0,
                "file_path": "test_queries.py",
                "trace": "client = <httpx.Client object at 0xffffac962050>\n\n    def test_single_query_loads_exactly_one_type1_and_one_type2(client):\n        \"\"\"\n        CRITICAL: Each query should load EXACTLY 1 Type1 and 1 Type2 value.\n        This validates that CSV chunking is working correctly.\n        \"\"\"\n        response = client.get(\"/query\", params={\"type1\": \"electronics\", \"type2\": \"phones\"})\n        assert response.status_code == 200\n    \n        loaded_response = client.get(\"/get_all_loaded_types_and_subtypes\")\n        assert loaded_response.status_code == 200\n        loaded_data = loaded_response.json()\n    \n        print(f\"\\n=== Single Query Efficiency ===\")\n        print(f\"Query: type1=electronics, type2=phones\")\n        print(f\"Loaded Type1 values: {loaded_data['type1_values']}\")\n        print(f\"Loaded Type2 values: {loaded_data['type2_values']}\")\n    \n        # MUST load EXACTLY 1 Type1\n>       assert len(loaded_data['type1_values']) == 1, \\\n            f\"FAIL: Expected exactly 1 Type1 value, got {len(loaded_data['type1_values'])}\"\nE       AssertionError: FAIL: Expected exactly 1 Type1 value, got 10\nE       assert 10 == 1\nE        +  where 10 = len(['automotive', 'beauty', 'books', 'clothing', 'electronics', 'food', ...])\n\n/tests/test_queries.py:203: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_queries.py::test_multiple_queries_each_loads_only_requested_data",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0038819999999759602,
                "start": 1764017937.8285673,
                "stop": 1764017937.8348014,
                "retries": 0,
                "file_path": "test_queries.py",
                "trace": "client = <httpx.Client object at 0xffffacf63bd0>\n\n    def test_multiple_queries_each_loads_only_requested_data(client):\n        \"\"\"\n        Test that EACH individual query loads only its specific data.\n        This ensures CSV chunks are loaded independently per query.\n        \"\"\"\n        test_cases = [\n            (\"furniture\", \"chairs\"),\n            (\"clothing\", \"shoes\"),\n            (\"food\", \"fruits\")\n        ]\n    \n        for type1, type2 in test_cases:\n            response = client.get(\"/query\", params={\"type1\": type1, \"type2\": type2})\n            assert response.status_code == 200\n    \n            loaded_response = client.get(\"/get_all_loaded_types_and_subtypes\")\n            assert loaded_response.status_code == 200\n            loaded_data = loaded_response.json()\n    \n            print(f\"\\n=== Multiple Query Test: {type1}/{type2} ===\")\n            print(f\"Loaded Type1 values: {loaded_data['type1_values']}\")\n            print(f\"Loaded Type2 values: {loaded_data['type2_values']}\")\n    \n            # Each query must load EXACTLY 1 Type1 and 1 Type2\n>           assert len(loaded_data['type1_values']) == 1, \\\n                f\"Query ({type1}, {type2}) loaded {len(loaded_data['type1_values'])} Type1 values instead of 1\"\nE           AssertionError: Query (furniture, chairs) loaded 10 Type1 values instead of 1\nE           assert 10 == 1\nE            +  where 10 = len(['automotive', 'beauty', 'books', 'clothing', 'electronics', 'food', ...])\n\n/tests/test_queries.py:239: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_queries.py::test_catastrophic_memory_inefficiency_detection",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.003736584000023413,
                "start": 1764017937.8348806,
                "stop": 1764017937.841342,
                "retries": 0,
                "file_path": "test_queries.py",
                "trace": "client = <httpx.Client object at 0xffffac961dd0>\n\n    def test_catastrophic_memory_inefficiency_detection(client):\n        \"\"\"\n        CRITICAL: Verify that only the queried data is loaded into memory.\n        If more than 1 Type1 or 1 Type2 is loaded, the implementation is inefficient.\n        \"\"\"\n        # Execute a single query\n        response = client.get(\"/query\", params={\"type1\": \"electronics\", \"type2\": \"phones\"})\n        assert response.status_code == 200\n    \n        # Check what was loaded into memory\n        loaded_response = client.get(\"/get_all_loaded_types_and_subtypes\")\n        assert loaded_response.status_code == 200\n        loaded_data = loaded_response.json()\n    \n        loaded_type1_count = len(loaded_data['type1_values'])\n        loaded_type2_count = len(loaded_data['type2_values'])\n    \n        print(f\"\\n=== MEMORY EFFICIENCY CHECK ===\")\n        print(f\"Query: type1=electronics, type2=phones\")\n        print(f\"Loaded into memory: {loaded_type1_count} Type1, {loaded_type2_count} Type2\")\n        print(f\"Type1 loaded: {loaded_data['type1_values']}\")\n        print(f\"Type2 loaded: {loaded_data['type2_values']}\")\n    \n        # PRIMARY ASSERTION: Must load EXACTLY 1 of each\n>       assert loaded_type1_count == 1, \\\n            f\"\u274c MEMORY INEFFICIENCY: Loaded {loaded_type1_count} Type1 values instead of 1! \" \\\n            f\"This indicates poor data organization. Loaded: {loaded_data['type1_values']}\"\nE       AssertionError: \u274c MEMORY INEFFICIENCY: Loaded 10 Type1 values instead of 1! This indicates poor data organization. Loaded: ['automotive', 'beauty', 'books', 'clothing', 'electronics', 'food', 'furniture', 'home', 'sports', 'toys']\nE       assert 10 == 1\n\n/tests/test_queries.py:274: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_queries.py::test_empty_query_loads_nothing",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.003767041000003246,
                "start": 1764017937.8414183,
                "stop": 1764017937.8474987,
                "retries": 0,
                "file_path": "test_queries.py",
                "trace": "client = <httpx.Client object at 0xffffac9e0fd0>\n\n    def test_empty_query_loads_nothing(client):\n        \"\"\"Test that queries returning no results don't load any data\"\"\"\n        response = client.get(\"/query\", params={\"type1\": \"nonexistent\", \"type2\": \"invalid\"})\n        assert response.status_code == 200\n        results = response.json()\n        assert len(results) == 0\n    \n        loaded_response = client.get(\"/get_all_loaded_types_and_subtypes\")\n        assert loaded_response.status_code == 200\n        loaded_data = loaded_response.json()\n    \n        print(f\"\\n=== Empty Query Test ===\")\n        print(f\"Query: type1=nonexistent, type2=invalid\")\n        print(f\"Loaded Type1 values: {loaded_data['type1_values']}\")\n        print(f\"Loaded Type2 values: {loaded_data['type2_values']}\")\n    \n        # For non-existent data, should load 0 values (chunk doesn't exist)\n>       assert len(loaded_data['type1_values']) == 0, \\\n            f\"Non-existent query loaded {len(loaded_data['type1_values'])} Type1 values\"\nE       AssertionError: Non-existent query loaded 10 Type1 values\nE       assert 10 == 0\nE        +  where 10 = len(['automotive', 'beauty', 'books', 'clothing', 'electronics', 'food', ...])\n\n/tests/test_queries.py:310: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            }
        ]
    }
}